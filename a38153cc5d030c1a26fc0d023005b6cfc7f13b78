{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1059b362_e530d559",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1620010
      },
      "writtenOn": "2021-02-17T17:27:10Z",
      "side": 1,
      "message": "I think I\u0027ve been added to this as I\u0027m part of the informal Android Rust readability reviewer rotation.\n\nI\u0027m -1ing this, but I think it requires a bit of policy discussion within the Android team about the preferred approach to C++ bindings generation.\n\nThe two options on the table are:\n- bindgen. Requires \u0027unsafe\u0027 wrappers (as you\u0027ve added in this CL)\n- cxx. Automatically generates the \u0027unsafe\u0027 wrapper. (https://github.com/dtolnay/cxx)\n\nNearly all the code you\u0027ve written here would be automatically generated from something like:\n\n#[cxx::bridge]\nmod base {\n  extern \"C\" {\n    fn GetProperty(a: \u0026CxxString, b: \u0026CxxString) -\u003e UniquePtr\u003cCxxString\u003e;\n  }\n}\n\n(that may not be exactly right but it\u0027s pretty close). Both C++ and Rust side wrapper functions are autogenerated and it would do pretty much exactly the same argument marshalling that you do.\n\nYou\u0027d still need small wrapper functions on both C++ and Rust side, but crucially, you would not have to write \u0027unsafe\u0027 around any code; there would be no pointer manipulation, and therefore possibilities for error are much reduced.\n\nYou might instead decide to pass \u0026str and String within that cxx::bridge function signature. That\u0027s probably what I\u0027d do. That way, you can avoid a Rust-side wrapper function. The C++ wrapper function would convert the rust::Strs into std::strings and vice-versa. e.g.\n\n#[cxx::bridge]\nmod base {\n  extern \"C\" {\n    fn GetProperty(a: \u0026str, b: \u0026str) -\u003e String;\n  }\n}\n\nThe C++ implementation of GetProperty would probably boil down to a single function call into android::base::GetProperty which involves casting between the Rust and C++ strings:\nhttps://cxx.rs/binding/str.html\nhttps://cxx.rs/binding/string.html\n(but note the UTF8 throw possibility when constructing a rust::String)\n\ncxx is in use in the new Android Rust Bluetooth stack and I think is widely viewed as the direction that Android Rust/C++ interop is headed.\n\nDue to the greater safety (and reduced code!) I think cxx should be the default, with bindgen only used in special circumstances where cxx really can\u0027t do the job. However I think that\u0027s an Android team policy decision. Please do feel free to discuss with folks like mmaurer@ (appears OOO this week) and jeffv@.\n\nI have not reviewed the specifics of this CL yet due to the above question. If the Android team policy is that bindgen is OK in these situations, Iâ€™m happy to review the code itself.\n\n",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c2b681ad_275bfa03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1087625
      },
      "writtenOn": "2021-02-17T17:43:36Z",
      "side": 1,
      "message": "Thanks for the review, Adrian! The last time I tried the cxx solution and it was not able to handle String as a return type, maybe cxx recently gained this feature.\n\nJeff, I have already checked in several libraries using the bindgen approach, similar to this CL. What\u0027s your opinion on this? Should I convert everything to use cxx instead?",
      "parentUuid": "1059b362_e530d559",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5967ab52_4ed1990e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1620010
      },
      "writtenOn": "2021-02-17T17:53:49Z",
      "side": 1,
      "message": "I believe either of these are options for the return type:\n\nString\nUniquePtr\u003cCxxString\u003e\n\nbut not\n\nCxxString",
      "parentUuid": "c2b681ad_275bfa03",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1db6cba4_07e0bb28",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2021-02-18T08:01:02Z",
      "side": 1,
      "message": "Yes, please convert to cxx. Do we need to update our cxx version before you can do that? If so, I can +2 this change so that you\u0027re not blocked waiting for us. Then you can update all your usage once it\u0027s available.",
      "parentUuid": "5967ab52_4ed1990e",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3976319a_81a88d5b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2021-02-18T08:08:52Z",
      "side": 1,
      "message": "Spoke with Yi about this. He\u0027ll properly convert to cxx in a follow up change.",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5449b7f0_36c64092",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1423874
      },
      "writtenOn": "2021-04-08T06:01:02Z",
      "side": 1,
      "message": "I came across this CL because my username is mentioned in the discussion.\n\nAdmittedly a biased drive-by reviewer, but strong +1 in favor of the cxx crate over bindgen for this type of thing. My work codebase used to have tens of thousands of lines of bindgen-based FFI that looked pretty much like this CL. Practically every binding I looked at had at least one memory leak, data race, or error codepath with double frees, including bindings written and reviewed by Rust experts. Bindings based on cxx have been close to foolproof in comparison, more concise/intuitive, and more approachable for contributors without already expertise in both Rust and C++.",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1938d835_005c9362",
        "filename": "profcollectd/libprofcollectd/bindings/libbase/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 23,
      "author": {
        "id": 1423874
      },
      "writtenOn": "2021-04-08T06:01:02Z",
      "side": 1,
      "message": "This function leaks an allocation on every call, which seems unintentional. The strdup inside GetProperty allocates using malloc. On the Rust side that allocated char* is being cast to \u0026str, but nothing ends up free-ing the original char* when the caller is done with the \u0026str they got.",
      "revId": "a38153cc5d030c1a26fc0d023005b6cfc7f13b78",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}