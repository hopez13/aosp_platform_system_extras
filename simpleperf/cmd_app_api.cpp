/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <fcntl.h>

#include <string>
#include <thread>
#include <vector>

#include <android-base/file.h>
#include <android-base/logging.h>
#include <android-base/parseint.h>
#include <android-base/strings.h>
#include <android-base/unique_fd.h>

#include "command.h"
#include "event_type.h"
#include "environment.h"
#include "utils.h"
#include "workload.h"

namespace {
const std::string simpleperf_data_dir = "simpleperf_data";

class PrepareCommand : public Command {
 public:
  PrepareCommand()
      : Command("app-api-prepare", "Prepare recording via app api",
                "Usage: simpleperf app-api-prepare\n"
                ) {}
  bool Run(const std::vector<std::string>& args);
};

bool PrepareCommand::Run(const std::vector<std::string>&) {
  // Enable profiling.
  if (!CheckPerfEventLimit()) {
    return false;
  }
  // Create tracepoint_events file.
  if (!android::base::WriteStringToFile(GetTracepointEvents(),
                                        "/data/local/tmp/tracepoint_events")) {
    PLOG(ERROR) << "failed to write tracepoint_events file";
    return false;
  }
  return true;
}

class CollectDataCommand : public Command {
 public:
  CollectDataCommand()
      : Command("app-api-collect", "Collect recording data generated by app api",
                // clang-format off
"Usage: simpleperf app-api-collect [options]\n"
"--app <package_name>    the android application having recording data\n"
"--out-dir <dir>         the directory to store recording data\n"
                // clang-format on
                ) {}

  bool Run(const std::vector<std::string>& args);

 private:
  bool ParseOptions(const std::vector<std::string>& args);
  bool SendProfilingData();
  bool RemoveProfilingData();
  bool ReceiveProfilingData();
  bool ReceiveDataThreadFunc(int in_fd);

  std::string app_name_;
  std::string out_dir_;
  bool in_app_context_ = false;
  android::base::unique_fd out_fd_;
};

bool CollectDataCommand::Run(const std::vector<std::string>& args) {
  if (!ParseOptions(args)) {
    return false;
  }
  if (in_app_context_) {
    return SendProfilingData() && RemoveProfilingData();
  }
  return ReceiveProfilingData();
}

bool CollectDataCommand::ParseOptions(const std::vector<std::string>& args) {
  for (size_t i = 0; i < args.size(); ++i) {
    if (args[i] == "--app") {
      if (!NextArgumentOrError(args, &i)) {
        return false;
      }
      app_name_ = args[i];
    } else if (args[i] == "--in-app") {
      in_app_context_ = true;
    } else if (args[i] == "--out-dir") {
      if (!NextArgumentOrError(args, &i)) {
        return false;
      }
      out_dir_ = args[i];
    } else if (args[i] == "--out-fd") {
      int fd;
      if (!GetUintOption(args, &i, &fd)) {
        return false;
      }
      out_fd_.reset(fd);
    } else if (args[i] == "--stop-signal-fd") {
      int fd;
      if (!GetUintOption(args, &i, &fd)) {
        return false;
      }
      // Stop signal fd isn't used.
    } else {
      ReportUnknownOption(args, i);
      return false;
    }
  }
  if (!in_app_context_) {
    if (app_name_.empty()) {
      LOG(ERROR) << "--app is missing";
      return false;
    }
    if (out_dir_.empty()) {
      LOG(ERROR) << "--out-dir is missing";
      return false;
    }
  }
  return true;
}

static bool SendFilename(const std::string& filename, int out_fd) {
  uint32_t name_size = filename.size();
  if (!android::base::WriteFully(out_fd, &name_size, sizeof(uint32_t)) ||
      !android::base::WriteFully(out_fd, filename.c_str(), name_size)) {
    PLOG(ERROR) << "failed to write to data pipe";
    return false;
  }
  return true;
}

static bool SendFileData(const std::string& file, int out_fd) {
  uint64_t file_size = GetFileSize(file);
  if (!android::base::WriteFully(out_fd, &file_size, sizeof(uint64_t))) {
    PLOG(ERROR) << "failed to write to data pipe";
    return false;
  }
  android::base::unique_fd in_fd(FileHelper::OpenReadOnly(file));
  if (in_fd == -1) {
    PLOG(ERROR) << "failed to open " << file;
    return false;
  }
  while (file_size > 0u) {
    ssize_t result = splice(in_fd, nullptr, out_fd, nullptr, file_size, 0);
    if (result <= 0) {
      PLOG(ERROR) << "failed to send file " << file;
      return false;
    }
    file_size -= result;
  }
  return true;
}

bool CollectDataCommand::SendProfilingData() {
  for (const auto& name : GetEntriesInDir(simpleperf_data_dir)) {
    // No need to send temporary file.
    const std::string file = simpleperf_data_dir + "/" + name;
    if (android::base::StartsWith(name, "TemporaryFile-") || !IsRegularFile(file)) {
      continue;
    }
    if (!SendFilename(name, out_fd_) || !SendFileData(file, out_fd_)) {
      return false;
    }
  }
  // Send name_size = 0 to notify the end.
  uint32_t name_size = 0;
  if (!android::base::WriteFully(out_fd_, &name_size, sizeof(uint32_t))) {
    PLOG(ERROR) << "failed to write to data pipe";
    return false;
  }
  return true;
}

bool CollectDataCommand::RemoveProfilingData() {
  return Workload::RunCmd({"rm", "-rf", simpleperf_data_dir});
}

bool CollectDataCommand::ReceiveProfilingData() {
  // Prepare out dir.
  if (!Workload::RunCmd({"rm", "-rf", out_dir_}) || !Workload::RunCmd({"mkdir", "-p", out_dir_})) {
    LOG(ERROR) << "failed to create dir " << out_dir_;
    return false;
  }
  android::base::unique_fd read_fd;
  android::base::unique_fd write_fd;
  if (!android::base::Pipe(&read_fd, &write_fd, 0)) {
    return false;
  }
  // Create read thread to receive profiling data.
  bool read_result = false;
  std::thread read_thread([&]() {
    read_result = ReceiveDataThreadFunc(read_fd);
  });

  // Create child process to send profiling data.
  if (!RunInAppContext(app_name_, Name(), {"--out-fd", std::to_string(write_fd.get())},
                       0, "", false)) {
    return false;
  }
  read_thread.join();
  return read_result;
}

static bool ReceiveFilename(int in_fd, std::string* filename) {
  uint32_t name_size;
  if (!android::base::ReadFully(in_fd, &name_size, sizeof(uint32_t))) {
    PLOG(ERROR) << "failed to read from data pipe";
    return false;
  }
  filename->resize(name_size);
  if (name_size > 0u && !android::base::ReadFully(in_fd, &(*filename)[0], name_size)) {
    PLOG(ERROR) << "failed to read from data pipe";
    return false;
  }
  return true;
}

static bool ReceiveFileData(int in_fd, const std::string& out_file) {
  uint64_t file_size;
  if (!android::base::ReadFully(in_fd, &file_size, sizeof(uint64_t))) {
    PLOG(ERROR) << "failed to read from data pipe";
    return false;
  }
  android::base::unique_fd out_fd(FileHelper::OpenWriteOnly(out_file));
  if (out_fd == -1) {
    PLOG(ERROR) << "failed to open " << out_file;
    return false;
  }
  while (file_size > 0u) {
    ssize_t result = splice(in_fd, nullptr, out_fd, nullptr, file_size, 0);
    if (result <= 0) {
      PLOG(ERROR) << "failed to receive file " << out_file;
      return false;
    }
    file_size -= result;
  }
  return true;
}

bool CollectDataCommand::ReceiveDataThreadFunc(int in_fd) {
  while (true) {
    std::string filename;
    if (!ReceiveFilename(in_fd, &filename)) {
      return false;
    }
    if (filename.empty()) {
      break;  // no more data
    }
    const std::string file = out_dir_ + "/" + filename;
    if (!ReceiveFileData(in_fd, file)) {
      return false;
    }
    LOG(INFO) << "Collect file " << file;
  }
  return true;
}
}  // namespace

void RegisterAppAPICommands() {
  RegisterCommand("app-api-prepare",
                  []{ return std::unique_ptr<Command>(new PrepareCommand()); });
  RegisterCommand("app-api-collect",
                  []{ return std::unique_ptr<Command>(new CollectDataCommand()); });
}
